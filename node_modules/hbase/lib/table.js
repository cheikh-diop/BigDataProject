// Generated by CoffeeScript 2.0.1
// # Table operations: create, modify and delete HBase tables

// ## Dependencies
var Row, Scanner, Table;

Row = require('./row');

Scanner = require('./scanner');

// ## Grab an instance of "hbase.Table"

// ```javascript
// var myTable = hbase({}).table('my_table');
// ```

// Or

// ```javascript
// var client = new hbase.Client({});
// var myTable = new hbase.Table(client, 'my_table');
// ```
Table = function(client, name) {
  this.client = client;
  this.name = name;
  return this;
};

// ## Create a new table in HBase

// ```javascript
// myTable.create(callback)
// ```

// Callback is optionnal and receive two arguments, an 
// error object if any and a boolean indicating whether 
// the table was created or not.

// The simplest way is to grab a table object and call 
// its `create` function with the schema as argument.

// ```javascript
// hbase()
// .table('my_new_table')
// .create('my_new_column', function(error, success){
//   console.log('Table created: ' + (success ? 'yes' : 'no'));
// } );
// ```

// For more control on the table and column family schema
//  configuration, the argument may be a full schema object. 
//  It doesn't need to contain the "name" property as it will 
//  be injected but may  contain the keys "is_meta" and "is_root" 
//  as well as the column family schemas. The column property 
//  must contain the key "name" and any other valid keys 
//  ("blocksize", "bloomfilter", "blockcache", "compression", 
//  "length", "versions", "ttl" and "in_memory").

// ```javascript
// hbase()
// .table( 'my_new_table' )
// .create( {
//   IS_META: false,
//   IS_ROOT: false,
//   COLUMNS: [{
//     NAME: 'my_new_column'
//   }]
// }, function( error, success ){
//   console.log('Table created: ' + (success ? 'yes' : 'no'));
// } );
// ```
Table.prototype.create = function(schema, callback) {
  var args;
  args = Array.prototype.slice.call(arguments);
  schema = args.length && typeof args[0] === 'object' || typeof args[0] === 'string' ? args.shift() : {};
  callback = args.length ? args.shift() : null;
  schema.name = this.name;
  if (typeof schema === 'string') {
    schema = {
      ColumnSchema: [
        {
          name: schema
        }
      ]
    };
  }
  return this.client.connection.put(`/${this.name}/schema`, schema, (error, data) => {
    if (!callback) {
      if (error) {
        throw error;
      } else {
        return;
      }
    }
    return callback.apply(this, [error, error ? null : true]);
  });
};

// ## Drop an existing table

// ```javascript
// myTable.delete(callback);
// ```

// Callback is optionnal and receive two arguments, an error object if any and a
// boolean indicating whether the table was removed/disabled or not.

// ```javascript
// hbase()
// .table('my_table')
// .delete(function(error, success){
//   assert.ok(success);
// });
// ```
Table.prototype.delete = function(callback) {
  return this.client.connection.delete(`/${this.name}/schema`, (error, data) => {
    if (!callback) {
      if (error) {
        throw error;
      } else {
        return;
      }
    }
    return callback.apply(this, [error, error ? null : true]);
  });
};

// ## Check if a table is created

// ```javascript
// myTable.exists(calblack);
// ```
Table.prototype.exists = function(callback) {
  return this.client.connection.get(`/${this.name}/exists`, (error, exists) => {
    if (error && error.code === 404) {
      error = null;
      exists = false;
    }
    return callback.apply(this, [error, error ? null : exists !== false]);
  });
};

// ## Update an existing table

// NOT YET WORKING, waiting for [HBASE-3140](https://issues.apache.org/jira/browse/HBASE-3140).
Table.prototype.update = function(schema, callback) {
  schema.name = this.name;
  return this.client.connection.post(`/${this.name}/schema`, schema, (error, data) => {
    if (!callback) {
      if (error) {
        throw error;
      } else {
        return;
      }
    }
    return callback.apply(this, [error, error ? null : true]);
  });
};

// ## Retrieves table schema

// ```javascript
// hbase()
// .table( 'my_new_table' )
// .schema(function(error, schema){
//   console.log(schema);
// });
// ```

// Will print something similar to:

// ```json
// { name: 'node_hbase'
// , IS_META: 'false'
// , IS_ROOT: 'false'
// , ColumnSchema:
//    [ { name: 'column_2'
//    , BLOCKSIZE: '65536'
//    , BLOOMFILTER: 'NONE'
//    , BLOCKCACHE: 'true'
//    , COMPRESSION: 'NONE'
//    , VERSIONS: '3'
//    , REPLICATION_SCOPE: '0'
//    , TTL: '2147483647'
//    , IN_MEMORY: 'false'
//    }
//    ]
// }
// ```
Table.prototype.schema = function(callback) {
  return this.client.connection.get(`/${this.name}/schema`, (error, data) => {
    return callback.apply(this, [error, error ? null : data]);
  });
};

// ## Retrieves table region metadata

// ```javascript
// hbase()
// .table( 'my_new_table' )
// .regions(function(error, regions){
//   console.log(regions);
// });
// ```

// Will print something similar to:

// ```json
// { name: 'node_hbase'
// , Region: 
//    [ { startKey: ''
//    , name: 'node_hbase,,1285801694075'
//    , location: 'eha.home:56243'
//    , id: 1285801694075
//    , endKey: ''
//    }
//    ]
// }
// ```
Table.prototype.regions = function(callback) {
  return this.client.connection.get(`/${this.name}/regions`, (error, data) => {
    return callback.apply(this, [error, error ? null : data]);
  });
};

// ## Return a new row instance

// ```javascript
// Table.row(key)
// ```
Table.prototype.row = function(key) {
  return new Row(this.client, this.name, key);
};

// ## Return a new scanner instance

// ```javascript
// Table.scan(options, callback)
// ```
Table.prototype.scan = function(options, callback) {
  var chunks, scanner;
  if (arguments.length === 0) {
    options = {};
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = options;
      options = {};
    }
  } else if (arguments.length !== 2) {
    throw Error('Invalid arguments');
  }
  options.table = this.name;
  scanner = new Scanner(this.client, options);
  if (callback) {
    chunks = [];
    scanner.on('readable', function() {
      var chunk, results;
      results = [];
      while (chunk = scanner.read()) {
        results.push(chunks.push(chunk));
      }
      return results;
    });
    scanner.on('error', function(err) {
      return callback(err);
    });
    scanner.on('end', function() {
      return callback(null, chunks);
    });
  }
  return scanner;
};

module.exports = Table;
